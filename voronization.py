############################################################################
# Routines for generating periodic Voronizations of arbitrary point sets   #
# defined on [0, 1]^n                                                      #
############################################################################

import numpy as np
from scipy.spatial import Voronoi


def points_near_unit_image(vor, idx):
    """
    Find the vertex in unit cell near the image of the vertex with index
    idx. Assumes a voronoi diagram vor generated from a point set in a
    3x3 replicated geometry spanning [-1, 2].
    """
    point = vor.vertices[idx]
    point = point % 1
    return np.where(np.linalg.norm(vor.vertices - point, axis=-1) < 1e-6)


def generate_point_array(points):
    dxdy = [
        [0, 0],
        [-1, -1],
        [0, -1],
        [1, -1],
        [1, 0],
        [1, 1],
        [0, 1],
        [-1, 1],
        [-1, 0]
    ]

    return np.concatenate(tuple(
        points + np.array(d) for d in dxdy
    ))


def generate_pbc_voronoi_adjacency(points):
    """
    From a given point set on [0, 1]^n, generate a PBC respecting adjacency
    list from the vertices of the Voronoi diagram.

    Args:
        points: np.array shape (npoints, n) - Point set on [0, 1]^n
    Returns:
        vertices: np.array shape (nvertices, ndim) - Voronoi diagram vertices
            on [0, 1]^n. Generated by cropping voronoi diagram of points tiled
            into a 3x3 lattice.
        adjacency: np.array shape (nedges, 2) - List of edges connecting points.
            Values are integers corresponding to indices in vertices.
    """
    points = generate_point_array(points)
    # Generate Voronoi diagram w/ SciPy
    vor = Voronoi(points)
    ridge_vertices = np.array(vor.ridge_vertices)
    # Select all ridges that begin in the unit cell
    start_vertices = vor.vertices[ridge_vertices[:, 0]]
    main_cell_indices = np.where(
        np.all(start_vertices > 0, axis=-
               1) & np.all(start_vertices < 1, axis=-1)
    )
    main_cell_ridges = np.array(ridge_vertices[main_cell_indices])
    # Map endpoints of ridges back to images in unit cell
    unit_images = np.array(
        list(map(lambda x: points_near_unit_image(vor, x), main_cell_ridges[:, 1])))
    # Replace endpoints of ridges with points inside unit cell
    pbc_start_ridges = main_cell_ridges
    pbc_start_ridges[:, 1] = np.squeeze(unit_images)
    # Repeat procedure for edges that end in the unit cell, replacing start
    # points
    end_vertices = vor.vertices[ridge_vertices[:, 1]]
    main_cell_indices = np.where(
        np.all(end_vertices > 0, axis=-1) & np.all(end_vertices < 1, axis=-1)
    )
    main_cell_ridges = np.array(ridge_vertices[main_cell_indices])
    unit_images = np.array(
        list(map(lambda x: points_near_unit_image(vor, x), main_cell_ridges[:, 0])))
    pbc_end_ridges = main_cell_ridges
    pbc_end_ridges[:, 0] = np.squeeze(unit_images)
    # Combine and remove duplicates (ridges that both start and end in unit)
    pbc_ridges = np.unique(np.concatenate(
        (pbc_start_ridges, pbc_end_ridges)), axis=0)
    # Create new list of vertices and indices of vertexes inside unit cell
    # generate list of unique indices
    indices_to_copy = list(set(pbc_ridges.flatten()))
    # list of vertices in same order as index list
    vertices_to_copy = vor.vertices[indices_to_copy]
    # map old indices to position in index list
    old_idx_to_new = {old: new for new, old in enumerate(indices_to_copy)}
    new_indices = np.array(
        list(map(lambda x: old_idx_to_new[x], pbc_ridges.flatten())))
    # use mapping to create list of new indices
    new_indices = new_indices.reshape(pbc_ridges.shape)
    return vertices_to_copy, new_indices


def create_strip_geometry(vertices, adjacency, axis=0):
    """
    From a point set on [0, 1]^2, remove any connections along axis larger
    than 1/2 - i.e. connections which span the system induced by periodic
    boundary conditions.

    Args:
        vertices: np.array shape (nvertices, ndim) - Voronoi diagram vertices
            on [0, 1]^n. Generated by cropping voronoi diagram of points tiled
            into a 3x3 lattice.
        adjacency: np.array shape (nedges, 2) - List of edges connecting points.
            Values are integers corresponding to indices in vertices.
        axis: int - Axis along which to crop system spanning connections
    Returns:
        vertices: np.array shape (nvertices, ndim) - Initial vertex array.
        adjacency: np.array shape (n_new_edges, 2) - New adjacency array with
            system spanning connections along axis snipped.
    """
    edge_vertices = vertices[adjacency]
    ev_pos_alongaxis = edge_vertices[..., axis]
    edge_lengths = np.abs(ev_pos_alongaxis[:, 0] - ev_pos_alongaxis[:, 1])
    span_idx = np.where(edge_lengths > 0.5)
    new_adjacency = np.delete(adjacency, span_idx, axis=0)
    return vertices, new_adjacency


def create_open_geometry(vertices, adjacency):
    """
    From a point set on [0, 1]^2, remove any connections larger
    than 1/2 - i.e. connections which span the system induced by periodic
    boundary conditions.

    Args:
        vertices: np.array shape (nvertices, ndim) - Voronoi diagram vertices
            on [0, 1]^n. Generated by cropping voronoi diagram of points tiled
            into a 3x3 lattice.
        adjacency: np.array shape (nedges, 2) - List of edges connecting points.
            Values are integers corresponding to indices in vertices.
        axis: int - Axis along which to crop system spanning connections
    Returns:
        vertices: np.array shape (nvertices, ndim) - Initial vertex array.
        adjacency: np.array shape (n_new_edges, 2) - New adjacency array with
            system spanning connections snipped.
    """
    edge_vertices = vertices[adjacency]
    edge_lengths = np.linalg.norm(
        edge_vertices[:, 0] - edge_vertices[:, 1], axis=-1)
    span_idx = np.where(edge_lengths > 0.5)
    new_adjacency = np.delete(adjacency, span_idx, axis=0)
    return vertices, new_adjacency
